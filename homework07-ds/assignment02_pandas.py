# -*- coding: utf-8 -*-
"""assignment02_pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xMxtblzo7Gh7x7v_GZYsbH5TZYyQECM9

<img src="../../img/ods_stickers.jpg">

## <center> [mlcourse.ai](https://mlcourse.ai) – открытый курс OpenDataScience по машинному обучению 
    
Автор материала: Екатерина Демидова, Data Scientist @ Segmento. Материал распространяется на условиях лицензии [Creative Commons CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/). Можно использовать в любых целях (редактировать, поправлять и брать за основу), кроме коммерческих, но с обязательным упоминанием автора материала.
Автор материала:

# <center>Домашнее задание № 2 (демо). <br> Визуальный анализ данных о публикациях на Хабрахабре</center>

**Заполните код в клетках и ответьте на вопросы в [веб-форме](https://docs.google.com/forms/d/1y8qj5iYpaVhczjWnZuHd5NRR_sdCGy3eTF5n-qPKknQ).**
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd

# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns

"""## Загрузка и знакомство с данными

Для работы вам понадобятся предобработанные данные нашего учебного конкурса на kaggle [«Прогноз популярности статьи на Хабре»](https://www.kaggle.com/c/howpop-habrahabr-favs). Скачайте [данные](https://drive.google.com/file/d/1nV2qV9otN3LnVSDqy95hvpJdb6aWtATk/view?usp=sharing) соревнования (данные были удалены с Kaggle ради организации последующего идентичного соревнования, так что тут ссылка на Google Drive).
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import io
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import os

# при необходимости поменяйте путь к данным
from google.colab import files
uploaded = files.upload()

data_frame = pd.read_csv("howpop_train.csv") #delimiter=",", names = ["url", "domain", "post_id", "published", "author", "flow", "polling", "content_len", "title", "comments", "favs", "views", "votes_plus", "votes_minus", "views_lognorm", "favs_lognorm", "comments_lognorm"])

data_frame.shape

data_frame.head(3).T

"""Избавимся сразу от переменных, названия которых заканчиваются на `_lognorm` (нужны для соревнования на Kaggle). Выберем их с помощью `filter()` и удалим `drop`-ом:"""

data_frame.drop(
    filter(lambda c: c.endswith("_lognorm"), data_frame.columns),
    axis=1,  # axis = 1: столбцы
    inplace=True,
)  # избавляет от необходимости сохранять датасет

data_frame.describe().T

data_frame.describe(include=["object", "bool"]).T  # бинарные и категориальные переменные

# настройка внешнего вида графиков в seaborn
sns.set_style("dark")
sns.set_palette("RdBu")
sns.set_context(
    "notebook", font_scale=1.5, rc={"figure.figsize": (15, 5), "axes.titlesize": 18}
)

"""Столбец **`published`** (время публикации) содержит строки. Чтобы мы могли работать с этими данными как с датой/временем публикации, приведём их к типу `datetime`:"""

print(data_frame.published.dtype)
data_frame["published"] = pd.to_datetime(data_frame.published, yearfirst=True)
print(data_frame.published.dtype)

"""Создадим несколько столбцов на основе данных о времени публикации:"""

data_frame["year"] = [d.year for d in data_frame.published]
data_frame["month"] = [d.month for d in data_frame.published]

data_frame["dayofweek"] = [d.isoweekday() for d in data_frame.published]
data_frame["hour"] = [d.hour for d in data_frame.published]

"""-----
Теперь Ваша очередь. В каждом пункте предлагается построить картинку и с ее помощью ответить на вопрос в [форме](https://docs.google.com/forms/d/e/1FAIpQLSf3b5OG8zX_nLQBQ-t20c6M5Auz-VUL-yxj8Fm9_o_XWDBTrg/viewform?c=0&w=1). Конечно, можно попытаться ответить на все вопросы только с Pandas, без картинок, но мы советуем Вам потренироваться строить (красивые) визуализации.

## 1\. В каком месяце (и какого года) было больше всего публикаций?

* март 2016
* март 2015
* апрель 2015
* апрель 2016
"""

march_2015 = data_frame.query("year == 2015 & month == 3").shape[0]
march_2015

march_2016 = data_frame.query("year == 2016 & month == 3").shape[0]
march_2016

april_2015 = data_frame.query("year == 2015 & month == 4").shape[0]
april_2015

april_2016 = data_frame.query("year == 2016 & month == 4").shape[0]
april_2016

data_frame.drop(filter(lambda c: c.endswith('_lognorm'), data_frame.columns),
        axis = 1,
        inplace = True)

sns.set_style('white')
sns.set_palette("RdBu")
sns.set_context("notebook", font_scale = 0.75,
                rc = {"figure.figsize" : (30, 15), "axes.titlesize" : 12 })

march_or_april = pd.DataFrame({"2015": [march_2015, april_2015], "2016": [march_2016, april_2016]}, index=["March", "April"])
march_or_april.plot.bar(color=["green", "black"],
                       rot=0);

"""## 2\. Проанализируйте публикации в месяце из предыдущего вопроса

Выберите один или несколько вариантов:

* Один или несколько дней сильно выделяются из общей картины
* На хабре _всегда_ больше статей, чем на гиктаймсе
* По субботам на гиктаймс и на хабрахабр публикуют примерно одинаковое число статей

Подсказки: постройте график зависимости числа публикаций от дня; используйте параметр `hue`; не заморачивайтесь сильно с ответами и не ищите скрытого смысла :)
"""

#Один или несколько дней сильно выделяются из общей картины
data_frame['dates'] = [str(p)[:7] for p in data_frame.published]
list = data_frame.dates.value_counts().index[0]
df_popmonth = data_frame[data_frame.dates == list]
df_popmonth['day'] = [p.day for p in df_popmonth.published]
sns.countplot(x = 'day', data = df_popmonth)

#На хабре всегда больше статей, чем на гиктаймсе
snscountplot(x = 'day', hue = 'domain', data = df_popmonth, palette="Set1")



"""## 3\. Когда лучше всего публиковать статью?

* Больше всего просмотров набирают статьи, опубликованные в 12 часов дня
* У опубликованных в 10 утра постов больше всего комментариев
* Больше всего просмотров набирают статьи, опубликованные в 6 часов утра
* Максимальное число комментариев на гиктаймсе набрала статья, опубликованная в 9 часов вечера
* На хабре дневные статьи комментируют чаще, чем вечерние
"""

print(data_frame.groupby('hour')['views'].mean().sort_values(ascending=False)[:5])

print(data_frame.groupby('hour')['comments'].mean().sort_values(ascending=False)[:5])

print(data_frame[data_frame.domain == 'habrahabr.ru'].groupby('hour')['comments'].mean().sort_values(ascending=False)[:5])

data_frame[data_frame.domain == 'habrahabr.ru'].groupby('hour')[['comments']].mean().plot()

"""## 4\. Кого из топ-20 авторов чаще всего минусуют?

* @Mordatyj
* @Mithgol
* @alizar
* @ilya42
"""

data_frame[data_frame.author.isin(['@Mordatyj','@Mithgol', '@alizar', '@ilya42'])].groupby('author')[['votes_minus']].mean().sort_values('votes_minus', ascending = False)

who = pd.DataFrame({"votes_minus": [20.481081, 7.928191, 7.471455, 6.216797]}, index=["@Mithgol", "@alizar", "@Mordatyj", "@ilya42"])
who.plot.bar(color=["green", "dimgrey", "black", "blue"],
                       rot=0);

"""## 5\. Сравните субботы и понедельники

Правда ли, что по субботам авторы пишут в основном днём, а по понедельникам — в основном вечером?
"""

fig = plt.figure(figsize=(20,20))
fig.add_subplot(1,1,1)
pl = sns.countplot(y = 'hour', hue = 'dayofweek', data = data_frame[data_frame.dayofweek.isin([1, 6])], palette="Set2")
pl.set_title("Количество публикаций за час", fontweight = 'bold')